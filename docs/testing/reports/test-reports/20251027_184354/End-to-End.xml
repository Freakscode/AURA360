<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="5" skipped="0" tests="6" time="6.299" timestamp="2025-10-27T18:44:13.459678-05:00" hostname="gabo288.local"><testcase classname="tests.e2e.test_full_integration_flow.TestE2EFullFlow" name="test_complete_advice_flow_mind_category" time="6.112"><failure message="assert 404 in [200, 201]&#10; +  where 404 = &lt;Response [404]&gt;.status_code">self = &lt;e2e.test_full_integration_flow.TestE2EFullFlow object at 0x10af76990&gt;
verify_all_services = None
ingest_test_documents = [{'doc_id': 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538-mind-meditation', 'metadata': {'category': 'mind', 'languag...io de gratitud y reconocer tres cosas positivas cada día aumenta la satisfacción vital y reduce síntomas depresivos.'}]
auth_token = 'test-token-replace-with-real-auth'
test_user_id = 'test-user-201b9e29-3f41-4fd4-8fff-6f4429abcaa1'
test_trace_id = 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538'

    def test_complete_advice_flow_mind_category(
        self,
        verify_all_services: None,
        ingest_test_documents: list[dict[str, Any]],
        auth_token: str,
        test_user_id: str,
        test_trace_id: str,
    ) -&gt; None:
        """
        Flujo completo: Cliente → Backend → Agentes → Vector Search → Respuesta.
        Categoría: mind (mente).
        """
        # 1. Cliente envía solicitud al backend
        request_payload = {
            "user_id": test_user_id,
            "category": "mind",
            "metadata": {
                "context": "Me siento estresado por el trabajo y necesito técnicas de relajación.",
                "urgency": "medium",
            },
        }
    
        headers = {"Authorization": f"Bearer {auth_token}"}
    
        start_time = time.perf_counter()
        response = requests.post(
            f"{BACKEND_URL}/api/v1/holistic/advice",
            json=request_payload,
            headers=headers,
            timeout=REQUEST_TIMEOUT,
        )
        total_latency_ms = (time.perf_counter() - start_time) * 1000
    
        # 2. Validar respuesta del backend
&gt;       assert response.status_code in [200, 201]
E       assert 404 in [200, 201]
E        +  where 404 = &lt;Response [404]&gt;.status_code

tests/e2e/test_full_integration_flow.py:221: AssertionError</failure></testcase><testcase classname="tests.e2e.test_full_integration_flow.TestE2EFullFlow" name="test_complete_advice_flow_holistic_category" time="0.006"><failure message="assert 404 in [200, 201]&#10; +  where 404 = &lt;Response [404]&gt;.status_code">self = &lt;e2e.test_full_integration_flow.TestE2EFullFlow object at 0x10b171e50&gt;
verify_all_services = None
ingest_test_documents = [{'doc_id': 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538-mind-meditation', 'metadata': {'category': 'mind', 'languag...io de gratitud y reconocer tres cosas positivas cada día aumenta la satisfacción vital y reduce síntomas depresivos.'}]
auth_token = 'test-token-replace-with-real-auth'
test_user_id = 'test-user-201b9e29-3f41-4fd4-8fff-6f4429abcaa1'
test_trace_id = 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538'

    def test_complete_advice_flow_holistic_category(
        self,
        verify_all_services: None,
        ingest_test_documents: list[dict[str, Any]],
        auth_token: str,
        test_user_id: str,
        test_trace_id: str,
    ) -&gt; None:
        """
        Flujo completo con categoría holistic (integral).
        Debe integrar recomendaciones de múltiples dimensiones.
        """
        request_payload = {
            "user_id": test_user_id,
            "category": "holistic",
            "metadata": {
                "context": "Quiero un plan integral para mejorar mi bienestar general.",
                "goals": ["reducir estrés", "aumentar energía", "conectar con propósito"],
            },
        }
    
        headers = {"Authorization": f"Bearer {auth_token}"}
    
        response = requests.post(
            f"{BACKEND_URL}/api/v1/holistic/advice",
            json=request_payload,
            headers=headers,
            timeout=REQUEST_TIMEOUT,
        )
    
&gt;       assert response.status_code in [200, 201]
E       assert 404 in [200, 201]
E        +  where 404 = &lt;Response [404]&gt;.status_code

tests/e2e/test_full_integration_flow.py:284: AssertionError</failure></testcase><testcase classname="tests.e2e.test_full_integration_flow.TestE2EFullFlow" name="test_vector_search_returns_relevant_results" time="0.061"><failure message="assert 0 &gt; 0&#10; +  where 0 = len([])">self = &lt;e2e.test_full_integration_flow.TestE2EFullFlow object at 0x10b1776f0&gt;
verify_all_services = None
ingest_test_documents = [{'doc_id': 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538-mind-meditation', 'metadata': {'category': 'mind', 'languag...io de gratitud y reconocer tres cosas positivas cada día aumenta la satisfacción vital y reduce síntomas depresivos.'}]
test_trace_id = 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538'

    def test_vector_search_returns_relevant_results(
        self,
        verify_all_services: None,
        ingest_test_documents: list[dict[str, Any]],
        test_trace_id: str,
    ) -&gt; None:
        """
        Valida que la búsqueda vectorial retorna resultados relevantes
        para los documentos ingestados.
        """
        # Buscar sobre meditación (debe encontrar el documento mind)
        search_payload = {
            "query": "técnicas de meditación para reducir estrés",
            "limit": 5,
            "filter": {
                "must": {
                    "trace_id": test_trace_id,
                }
            },
        }
    
        response = requests.post(
            f"{VECTORIAL_SERVICE_URL}/search",
            json=search_payload,
            timeout=REQUEST_TIMEOUT,
        )
    
        assert response.status_code == 200
        data = response.json()
    
        assert "hits" in data
        hits = data["hits"]
&gt;       assert len(hits) &gt; 0
E       assert 0 &gt; 0
E        +  where 0 = len([])

tests/e2e/test_full_integration_flow.py:329: AssertionError</failure></testcase><testcase classname="tests.e2e.test_full_integration_flow.TestE2EErrorScenarios" name="test_invalid_category_returns_error" time="0.006" /><testcase classname="tests.e2e.test_full_integration_flow.TestE2EErrorScenarios" name="test_unauthorized_request_returns_401" time="0.004"><failure message="assert 404 == 401&#10; +  where 404 = &lt;Response [404]&gt;.status_code">self = &lt;e2e.test_full_integration_flow.TestE2EErrorScenarios object at 0x10b171f90&gt;
verify_all_services = None
test_user_id = 'test-user-201b9e29-3f41-4fd4-8fff-6f4429abcaa1'

    def test_unauthorized_request_returns_401(
        self,
        verify_all_services: None,
        test_user_id: str,
    ) -&gt; None:
        """Valida que solicitudes sin autenticación retornan 401."""
        request_payload = {
            "user_id": test_user_id,
            "category": "mind",
            "metadata": {},
        }
    
        # Sin headers de autorización
        response = requests.post(
            f"{BACKEND_URL}/api/v1/holistic/advice",
            json=request_payload,
            timeout=REQUEST_TIMEOUT,
        )
    
&gt;       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = &lt;Response [404]&gt;.status_code

tests/e2e/test_full_integration_flow.py:385: AssertionError</failure></testcase><testcase classname="tests.e2e.test_full_integration_flow.TestE2EPerformance" name="test_concurrent_requests_are_handled" time="0.012"><failure message="requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)">self = &lt;Response [404]&gt;, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) &gt; 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
&gt;           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/json/decoder.py:345: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;json.decoder.JSONDecoder object at 0x10a0e70e0&gt;
s = '&lt;!DOCTYPE html&gt;\n&lt;html lang="en"&gt;\n&lt;head&gt;\n  &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;\n  &lt;... to &lt;code&gt;False&lt;/code&gt;, and Django\n      will display a standard 404 page.\n    &lt;/p&gt;\n  &lt;/footer&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
&gt;           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/json/decoder.py:363: JSONDecodeError

During handling of the above exception, another exception occurred:

self = &lt;e2e.test_full_integration_flow.TestE2EPerformance object at 0x10b1720d0&gt;
verify_all_services = None
ingest_test_documents = [{'doc_id': 'e2e-test-8206cffc-d572-436b-9476-8e8fbc68b538-mind-meditation', 'metadata': {'category': 'mind', 'languag...io de gratitud y reconocer tres cosas positivas cada día aumenta la satisfacción vital y reduce síntomas depresivos.'}]
auth_token = 'test-token-replace-with-real-auth'
test_user_id = 'test-user-201b9e29-3f41-4fd4-8fff-6f4429abcaa1'

    def test_concurrent_requests_are_handled(
        self,
        verify_all_services: None,
        ingest_test_documents: list[dict[str, Any]],
        auth_token: str,
        test_user_id: str,
    ) -&gt; None:
        """
        Valida que el sistema puede manejar múltiples solicitudes concurrentes.
        """
        import concurrent.futures
    
        def make_request(category: str) -&gt; dict[str, Any]:
            """Hace una solicitud al backend."""
            payload = {
                "user_id": test_user_id,
                "category": category,
                "metadata": {"test": "concurrent"},
            }
            headers = {"Authorization": f"Bearer {auth_token}"}
    
            response = requests.post(
                f"{BACKEND_URL}/api/v1/holistic/advice",
                json=payload,
                headers=headers,
                timeout=REQUEST_TIMEOUT,
            )
            return response.json()
    
        # Hacer 3 solicitudes concurrentes
        categories = ["mind", "body", "soul"]
    
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            futures = [executor.submit(make_request, cat) for cat in categories]
&gt;           results = [future.result() for future in concurrent.futures.as_completed(futures)]
                       ^^^^^^^^^^^^^^^

tests/e2e/test_full_integration_flow.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py:449: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py:401: in __get_result
    raise self._exception
/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
tests/e2e/test_full_integration_flow.py:418: in make_request
    return response.json()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;Response [404]&gt;, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) &gt; 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
&gt;           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/requests/models.py:980: JSONDecodeError</failure></testcase></testsuite></testsuites>